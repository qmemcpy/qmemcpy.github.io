<!DOCTYPE html>
<html lang="en">

	<head>
		<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1" />


	<title>Reverse engineering malware: TrickBot (part 3 - core)</title>


<meta name="twitter:card" content="summary" />
<meta name="twitter:site" content="@qmemcpy" />
<meta name="twitter:title" content="Reverse engineering malware: TrickBot (part 3 - core)" />
<meta name="twitter:description" content="In my previous post, I explained how to dump the TrickBot core.In this one, I will show a bunch of tricks that will make the analysis of said core easier. This is not a full malware analysis - I do...">

<meta name="description" content="In my previous post, I explained how to dump the TrickBot core.In this one, I will show a bunch of tricks that will make the analysis of said core easier. Th...">


	<meta name="google-site-verification" content="epFgX0s_0RM3CdjwFcsewfXzPov2g8s9ZBOLyaIUH-o">


<link rel="icon" href="/assets/favicon.png">
<link rel="apple-touch-icon" href="/assets/touch-icon.png">
<link href="https://fonts.googleapis.com/css?family=Karla" rel="stylesheet">
<link rel="stylesheet" href="/assets/core.css">
<link rel="canonical" href="/post/reverse-engineering-malware-trickbot-part-3-core">
<link rel="alternate" type="application/atom+xml" title="qmemcpy - random bits of reverse engineering" href="/feed.xml" />





<!-- Begin Jekyll SEO tag v2.3.0 -->
<meta property="og:title" content="Reverse engineering malware: TrickBot (part 3 - core)" />
<meta name="author" content="qmempcy" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="In my previous post, I explained how to dump the TrickBot core. In this one, I will show a bunch of tricks that will make the analysis of said core easier. This is not a full malware analysis - I don’t intend to teach you malware reverse engineering, but rather, I’m aiming to make your reverse-engineering process less cumbersome and of higher quality. Starting analysis: automagically renaming imports We can see that the first thing the binary does is dynamically load a bunch of imports (not all, though): Given the knowledge gained from the previous posts of the TrickBot series, the next step is obvious: run the binary, load the imports, rename them, then have them nicely named in the IDB: However, even after renaming them, the pseudocode is ugly: IDA knows about this, too. Just select the entire table and right click, then select Create struct from selection: (IDA seems to not like imports_table as a struct name) Now, set the variable’s type to a pointer to whatever you named the previous structure (I chose import_table): Much better now! There are more imports loaded dynamically a bit further: But that can be fixed in no time using the classical method: Deep into the trick: Task Scheduler and COM TrickBot makes use of the Windows COM API to register itself as a task in the Task Scheduler. The problem with that, however, is that the COM API is C++, and is not exactly pretty in source, let alone binary: Luckily, there’s no need no reverse that indirection hell manually; it might sound like a nag at this point, but IDA already knows about this, too. It’s fairly easy as well. If you check the first parameter of the first indirect call, and trace it back to where it is initialized, you’ll see a call to CoCreateInstance: As the name suggests, that function is creating an instance. If there’s an instance, there must be a class. If you look at the documentation, you’ll see that the fourth argument is the riid, i.e. a reference to the identifier of the interface (basically, the descriptor of the class we’re after). And the value passed in this case is: .rdata:004131EC stru_4131EC dd 2FABA4C7h ; Data1 .rdata:004131EC ; DATA XREF: sub_401B60+55↑o .rdata:004131EC dw 4DA9h ; Data2 .rdata:004131EC dw 4013h ; Data3 .rdata:004131EC db 96h, 97h, 20h, 0CCh, 3Fh, 0D4h, 0Fh, 85h; Data4 (type: CLSID, available in the mssdk_win7 type library) To find out the name for this class, open the registry editor and go to HKEY_CLASSES_ROOT\Interface, and search for the first few bytes of the CLSID, {2FABA: The value at the right will be the class name you’re looking for: Now go back to IDA, and apply the type: Oops. That’s not it. That’s because the pointer is actually pointing to the vtable, not to the class layout with the function pointers. But, yet again, IDA knows about that, too! Simply change the type from ITaskService* to ITaskServiceVtbl*, and: Keep doing that until you get a decently readable pseudocode, which can be easily understood at a simple glance: v4 = (*a1-&gt;task_service)-&gt;GetFolder((ITaskService *)a1-&gt;task_service, v3, &amp;task_folder); That’s it, for now. I haven’t found anything else worthy of surgically dissecting in a blog post, because the rest of the bot is just your average boring reversing, and I’m not gonna waste your time with that. However, if there’s interest, I can write another post, dissecting how the malware performs the MitB (Man-in-the-Browser) attack, or any of the modules it downloads. If you want to leave a comment, please do so on the reddit discussion." />
<meta property="og:description" content="In my previous post, I explained how to dump the TrickBot core. In this one, I will show a bunch of tricks that will make the analysis of said core easier. This is not a full malware analysis - I don’t intend to teach you malware reverse engineering, but rather, I’m aiming to make your reverse-engineering process less cumbersome and of higher quality. Starting analysis: automagically renaming imports We can see that the first thing the binary does is dynamically load a bunch of imports (not all, though): Given the knowledge gained from the previous posts of the TrickBot series, the next step is obvious: run the binary, load the imports, rename them, then have them nicely named in the IDB: However, even after renaming them, the pseudocode is ugly: IDA knows about this, too. Just select the entire table and right click, then select Create struct from selection: (IDA seems to not like imports_table as a struct name) Now, set the variable’s type to a pointer to whatever you named the previous structure (I chose import_table): Much better now! There are more imports loaded dynamically a bit further: But that can be fixed in no time using the classical method: Deep into the trick: Task Scheduler and COM TrickBot makes use of the Windows COM API to register itself as a task in the Task Scheduler. The problem with that, however, is that the COM API is C++, and is not exactly pretty in source, let alone binary: Luckily, there’s no need no reverse that indirection hell manually; it might sound like a nag at this point, but IDA already knows about this, too. It’s fairly easy as well. If you check the first parameter of the first indirect call, and trace it back to where it is initialized, you’ll see a call to CoCreateInstance: As the name suggests, that function is creating an instance. If there’s an instance, there must be a class. If you look at the documentation, you’ll see that the fourth argument is the riid, i.e. a reference to the identifier of the interface (basically, the descriptor of the class we’re after). And the value passed in this case is: .rdata:004131EC stru_4131EC dd 2FABA4C7h ; Data1 .rdata:004131EC ; DATA XREF: sub_401B60+55↑o .rdata:004131EC dw 4DA9h ; Data2 .rdata:004131EC dw 4013h ; Data3 .rdata:004131EC db 96h, 97h, 20h, 0CCh, 3Fh, 0D4h, 0Fh, 85h; Data4 (type: CLSID, available in the mssdk_win7 type library) To find out the name for this class, open the registry editor and go to HKEY_CLASSES_ROOT\Interface, and search for the first few bytes of the CLSID, {2FABA: The value at the right will be the class name you’re looking for: Now go back to IDA, and apply the type: Oops. That’s not it. That’s because the pointer is actually pointing to the vtable, not to the class layout with the function pointers. But, yet again, IDA knows about that, too! Simply change the type from ITaskService* to ITaskServiceVtbl*, and: Keep doing that until you get a decently readable pseudocode, which can be easily understood at a simple glance: v4 = (*a1-&gt;task_service)-&gt;GetFolder((ITaskService *)a1-&gt;task_service, v3, &amp;task_folder); That’s it, for now. I haven’t found anything else worthy of surgically dissecting in a blog post, because the rest of the bot is just your average boring reversing, and I’m not gonna waste your time with that. However, if there’s interest, I can write another post, dissecting how the malware performs the MitB (Man-in-the-Browser) attack, or any of the modules it downloads. If you want to leave a comment, please do so on the reddit discussion." />
<link rel="canonical" href="https://qmemcpy.io/post/reverse-engineering-malware-trickbot-part-3-core" />
<meta property="og:url" content="https://qmemcpy.io/post/reverse-engineering-malware-trickbot-part-3-core" />
<meta property="og:site_name" content="qmemcpy - random bits of reverse engineering" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-10-09T02:00:00+02:00" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:site" content="@qmemcpy" />
<meta name="twitter:creator" content="@qmemcpy" />
<script type="application/ld+json">
{"name":null,"description":"In my previous post, I explained how to dump the TrickBot core. In this one, I will show a bunch of tricks that will make the analysis of said core easier. This is not a full malware analysis - I don’t intend to teach you malware reverse engineering, but rather, I’m aiming to make your reverse-engineering process less cumbersome and of higher quality. Starting analysis: automagically renaming imports We can see that the first thing the binary does is dynamically load a bunch of imports (not all, though): Given the knowledge gained from the previous posts of the TrickBot series, the next step is obvious: run the binary, load the imports, rename them, then have them nicely named in the IDB: However, even after renaming them, the pseudocode is ugly: IDA knows about this, too. Just select the entire table and right click, then select Create struct from selection: (IDA seems to not like imports_table as a struct name) Now, set the variable’s type to a pointer to whatever you named the previous structure (I chose import_table): Much better now! There are more imports loaded dynamically a bit further: But that can be fixed in no time using the classical method: Deep into the trick: Task Scheduler and COM TrickBot makes use of the Windows COM API to register itself as a task in the Task Scheduler. The problem with that, however, is that the COM API is C++, and is not exactly pretty in source, let alone binary: Luckily, there’s no need no reverse that indirection hell manually; it might sound like a nag at this point, but IDA already knows about this, too. It’s fairly easy as well. If you check the first parameter of the first indirect call, and trace it back to where it is initialized, you’ll see a call to CoCreateInstance: As the name suggests, that function is creating an instance. If there’s an instance, there must be a class. If you look at the documentation, you’ll see that the fourth argument is the riid, i.e. a reference to the identifier of the interface (basically, the descriptor of the class we’re after). And the value passed in this case is: .rdata:004131EC stru_4131EC dd 2FABA4C7h ; Data1 .rdata:004131EC ; DATA XREF: sub_401B60+55↑o .rdata:004131EC dw 4DA9h ; Data2 .rdata:004131EC dw 4013h ; Data3 .rdata:004131EC db 96h, 97h, 20h, 0CCh, 3Fh, 0D4h, 0Fh, 85h; Data4 (type: CLSID, available in the mssdk_win7 type library) To find out the name for this class, open the registry editor and go to HKEY_CLASSES_ROOT\\Interface, and search for the first few bytes of the CLSID, {2FABA: The value at the right will be the class name you’re looking for: Now go back to IDA, and apply the type: Oops. That’s not it. That’s because the pointer is actually pointing to the vtable, not to the class layout with the function pointers. But, yet again, IDA knows about that, too! Simply change the type from ITaskService* to ITaskServiceVtbl*, and: Keep doing that until you get a decently readable pseudocode, which can be easily understood at a simple glance: v4 = (*a1-&gt;task_service)-&gt;GetFolder((ITaskService *)a1-&gt;task_service, v3, &amp;task_folder); That’s it, for now. I haven’t found anything else worthy of surgically dissecting in a blog post, because the rest of the bot is just your average boring reversing, and I’m not gonna waste your time with that. However, if there’s interest, I can write another post, dissecting how the malware performs the MitB (Man-in-the-Browser) attack, or any of the modules it downloads. If you want to leave a comment, please do so on the reddit discussion.","url":"https://qmemcpy.io/post/reverse-engineering-malware-trickbot-part-3-core","headline":"Reverse engineering malware: TrickBot (part 3 - core)","dateModified":"2017-10-09T02:00:00+02:00","datePublished":"2017-10-09T02:00:00+02:00","sameAs":null,"@type":"BlogPosting","author":{"@type":"Person","name":"qmempcy"},"image":null,"publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"https://qmemcpy.io/assets/command_line.png"},"name":"qmempcy"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://qmemcpy.io/post/reverse-engineering-malware-trickbot-part-3-core"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->



	</head>

	<body>

		<aside class="logo">

	
	

	<a href="/">
		<img src="/assets/command_line.png" class="gravatar">
	</a>

</aside>


		<main>
			<article>

	<div class="center">
		<h1>Reverse engineering malware: TrickBot (part 3 - core)</h1>
		<time>October 9, 2017</time>
	</div>

	<div class="divider"></div>

	<p>In my <a href="/post/reverse-engineering-malware-trickbot-part-2-loader">previous post</a>, I explained how to dump the TrickBot core.</p>

<p>In this one, I will show a bunch of tricks that will make the analysis of said core easier. This is <em>not</em> a full malware analysis - I don’t intend
to teach you malware reverse engineering, but rather, I’m aiming to make your reverse-engineering process less cumbersome and of higher quality.</p>

<hr />

<h1 id="starting-analysis-automagically-renaming-imports">Starting analysis: automagically renaming imports</h1>

<p>We can see that the first thing the binary does is dynamically load a bunch of imports (not all, though):</p>

<p><img src="https://i.imgur.com/fxUm5Y1.png" alt="loading imports" /></p>

<p>Given the knowledge gained from the previous posts of the TrickBot series, the next step is obvious: run the binary,
load the imports, rename them, then have them nicely named in the IDB:</p>

<p><img src="https://i.imgur.com/aO8A3Wq.png" alt="imports" /></p>

<p>However, even after renaming them, the pseudocode is ugly:</p>

<p><img src="https://i.imgur.com/aRtwE6K.png" alt="stupid pseudocode" /></p>

<p>IDA knows about this, too. Just select the entire table and right click, then select <code class="highlighter-rouge">Create struct from selection</code>:</p>

<p><img src="https://i.imgur.com/T8oFdcg.gif" alt="fix imports" /></p>

<p><em>(IDA seems to not like <code class="highlighter-rouge">imports_table</code> as a struct name)</em></p>

<p>Now, set the variable’s type to a pointer to whatever you named the previous structure (I chose <code class="highlighter-rouge">import_table</code>):</p>

<p><img src="https://i.imgur.com/OiLv5Ty.gif" alt="fixed imports, really" /></p>

<p>Much better now! There are more imports loaded dynamically a bit further:</p>

<p><img src="https://i.imgur.com/Jy4Sqrl.png" alt="even more imports" /></p>

<p>But that can be fixed in no time using the classical method:</p>

<p><img src="https://i.imgur.com/EF41TRW.png" alt="yay for imports" /></p>

<h1 id="deep-into-the-trick-task-scheduler-and-com">Deep into <em>the trick</em>: Task Scheduler and COM</h1>

<p>TrickBot makes use of the Windows COM API to register itself as a task in the Task Scheduler. The problem with that,
however, is that the COM API is C++, and is not exactly pretty in <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa383624(v=vs.85).aspx">source</a>, let alone binary:</p>

<p><img src="https://i.imgur.com/2B1IDfE.gif" alt="damn trickbot" /></p>

<p>Luckily, there’s no need no reverse that indirection hell manually; it might sound like a nag at this point, but <em>IDA already knows about this</em>, too.
It’s fairly easy as well. If you check the first parameter of the first indirect call, and trace it back to where it is initialized, you’ll see
a call to <code class="highlighter-rouge">CoCreateInstance</code>:</p>

<p><img src="https://i.imgur.com/GNTl9A7.png" alt="coinitialize" /></p>

<p>As the name suggests, that function is creating an <em>instance</em>. If there’s an instance, there must be a class. If you look at the <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms686615(v=vs.85).aspx">documentation</a>,
you’ll see that the fourth argument is the <code class="highlighter-rouge">riid</code>, i.e. a reference to the identifier of the interface (basically, the descriptor of the class we’re after). And the value passed in this case is:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>.rdata:004131EC stru_4131EC dd 2FABA4C7h                            ; Data1
.rdata:004131EC                                         ; DATA XREF: sub_401B60+55↑o
.rdata:004131EC dw 4DA9h                                ; Data2
.rdata:004131EC dw 4013h                                ; Data3
.rdata:004131EC db 96h, 97h, 20h, 0CCh, 3Fh, 0D4h, 0Fh, 85h; Data4
</code></pre>
</div>

<p><em>(type: <code class="highlighter-rouge">CLSID</code>, available in the <code class="highlighter-rouge">mssdk_win7</code> type library)</em></p>

<p>To find out the name for this class, open the registry editor and go to <code class="highlighter-rouge">HKEY_CLASSES_ROOT\Interface</code>, and search for the first few bytes of the CLSID, <code class="highlighter-rouge"><span class="p">{</span><span class="err">2FABA</span></code>:</p>

<p><img src="https://i.imgur.com/im8HB5p.png" alt="registry path" /></p>

<p>The value at the right will be the class name you’re looking for:</p>

<p><img src="https://i.imgur.com/pBsvviX.png" alt="itaskservice" /></p>

<p>Now go back to IDA, and apply the type:</p>

<p><img src="https://i.imgur.com/qm3KD6w.png" alt="wrong type" /></p>

<p>Oops. That’s not it. That’s because the pointer is actually pointing to the vtable, not to the class layout with the function pointers. But, yet again, <em>IDA knows about that</em>, too!
Simply change the type from <code class="highlighter-rouge">ITaskService*</code> to <code class="highlighter-rouge">ITaskServiceVtbl*</code>, and:</p>

<p><img src="https://i.imgur.com/TvbGeqV.png" alt="magic" /></p>

<p>Keep doing that until you get a decently readable pseudocode, which can be easily understood at a simple glance:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>v4 = (*a1-&gt;task_service)-&gt;GetFolder((ITaskService *)a1-&gt;task_service, v3, &amp;task_folder);
</code></pre>
</div>

<hr />

<p>That’s it, for now. I haven’t found anything else worthy of surgically dissecting in a blog post, because the rest of the bot is just your average boring reversing,
and I’m not gonna waste your time with that. However, if there’s interest, I can write another post, dissecting how the malware performs the MitB (Man-in-the-Browser)
attack, or any of the modules it downloads.</p>

<hr />

<p>If you want to leave a comment, please do so on <a href="https://www.reddit.com/r/ReverseEngineering/comments/75gutb/reverse_engineering_malware_trickbot_part_3_core/">the reddit discussion</a>.</p>


</article>

<div class="page-navigation">
	
		<a class="home" href="/" title="Back to Homepage">Home</a>
  
		<span> &middot; </span>
    <a class="prev" href="/post/reverse-engineering-malware-trickbot-part-2-loader" title="PREV: Reverse engineering malware: TrickBot (part 2 - loader)">&gt;&gt;</a>
  
</div>

		</main>

		<div class="footer">
  <span class="block">Made with &hearts; using <a href="http://jekyllrb.com/">Jekyll</a> &amp; <a href="https://github.com/heiswayi/the-plain" title="The Plain theme by Heiswayi Nrird">The Plain</a></span>
  <span class="block"><a href="https://github.com/qmemcpy" title="Hosted on GitHub" target="_blank">GitHub</a> &middot; <a href="https://twitter.com/qmemcpy" target="_blank">twitter</a> &middot; <a href="/about">about</a></span>
  <span>
  	feeds: <a href="/feed.xml" target="_blank">rss</a> &middot; <a href="/atom.xml" target="_blank">atom</a> &middot; <a href="/sitemap.xml" target="_blank">sitemap</a>
  </span>
  <span class="block">&copy; 2019 qmemcpy</span>
</div>

		<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-99919043-1', 'auto');
  ga('send', 'pageview');

</script>


	</body>

</html>
