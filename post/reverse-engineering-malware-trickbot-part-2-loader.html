<!DOCTYPE html>
<html lang="en">

	<head>
		<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1" />


	<title>Reverse engineering malware: TrickBot (part 2 - loader)</title>


<meta name="twitter:card" content="summary" />
<meta name="twitter:site" content="@qmemcpy" />
<meta name="twitter:title" content="Reverse engineering malware: TrickBot (part 2 - loader)" />
<meta name="twitter:description" content="In my previous post, I explained how to unpack the TrickBot loader.In this one, I will explain how to dump both versions of the core (x86 and x64). The dumping part in itself is not so interesting ...">

<meta name="description" content="In my previous post, I explained how to unpack the TrickBot loader.In this one, I will explain how to dump both versions of the core (x86 and x64). The dumpi...">


	<meta name="google-site-verification" content="epFgX0s_0RM3CdjwFcsewfXzPov2g8s9ZBOLyaIUH-o">


<link rel="icon" href="/assets/favicon.png">
<link rel="apple-touch-icon" href="/assets/touch-icon.png">
<link href="https://fonts.googleapis.com/css?family=Karla" rel="stylesheet">
<link rel="stylesheet" href="/assets/core.css">
<link rel="canonical" href="/post/reverse-engineering-malware-trickbot-part-2-loader">
<link rel="alternate" type="application/atom+xml" title="qmemcpy - random bits of reverse engineering" href="/feed.xml" />





<!-- Begin Jekyll SEO tag v2.3.0 -->
<meta property="og:title" content="Reverse engineering malware: TrickBot (part 2 - loader)" />
<meta name="author" content="qmempcy" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="In my previous post, I explained how to unpack the TrickBot loader. In this one, I will explain how to dump both versions of the core (x86 and x64). The dumping part in itself is not so interesting as are the ways you can make IDA help you easily understand what’s going on. Starting analysis After dropping the binary in IDA and poking around a bit, you see a bunch of functions and hidden imports, which doesn’t help much: This doesn’t really mean anything at this point, other than a bunch of random symbols. So, let’s get some runtime / dynamic information. If you run the binary, you’ll see something particularly interesting: It is the first called function, and some parameters are passed to it. If you step over it and check the values of those addresses, you’ll quickly see that, in the first parameter, there’s a number that looks like an offset: IDA also marked is as a function pointer, so if you put the cursor over it and press O (to mark as an offset), you get: Effectively, the 0x7XXXXXXX offset and the type information hints from IDA were right: it’s a function pointer, pointing to a Windows API call. This means that the function probably initializes the imports table. However, after initializing the imports, they still look ugly in the decompiler: off_404010(0); Of course, you could go and rename each API call manually, but really, you don’t want to do that. You have the start of the imports table, and if you look at the second parameter of the previously mentioned IAT-loading function, you see: .rdata:00403228 dword_403228 dd 200h ; DATA XREF: start+15↑o Indeed, that’s the size of the imports table, but, news flash: you don’t even need to know it! Prettifying the imports dword_xxxxxxxx(arg) does not help, but IDA already knows about these tricks, and is ready to help. To fix the ugly imports, all you have to do is find the start of the imports table, select it1 and then let IDA know about them. To do this, go to the previously mentioned offset (start of imports table), put the cursor there, and press Alt + L to start a new selection: that is, you’re telling IDA that, no matter if you lose the focus of the window or click somewhere, it should still keep the selection. This is very useful for when you have to select a big chunk of memory, such as an imports table: Then, as shown in the previous GIF, scroll down until you find the end, which you can find intuitively: when you stop seeing 0x7XXXXXXX offsets, then you’ve found the end of the imports table. It’s as easy as it sounds. And if you have multiple import tables (or a single import table is split over multiple regions), you can repeat the process with each chunk. Now that you have the table selected, it’s time to rename these offsets. Luckily, IDA already ships with an IDC script designed exactly for this purpose: ida_root/idc/renimp.idc. To use it, press Alt + F7, then navigate to the script, select it, press Alt + L again (to cancel the selection), and all the imports will be renamed: Now that we have the imports renamed, the binary looks much better: Compare that to the old view: Now that the binary is much easier to understand, we can quickly reverse some functions (without going too deep into it) and get a global overview of what is the binary doing: As mentioned in the title, this is just a loader that moves itself to a temporary directory, checks OS information (32-bit or 64-bit), and loads the appropiate binary. As you can see in the image, I’ve highlighted the variable that is used to decide which resource to load and decode, so in order to dump it, all you have to do is put a breakpoint after DecodeStream and dump len bytes from buf, then run the binary again, invert the if ( os_version ) check, and dump len bytes from buf, again, to have both binaries: ➜ ~ file * trickbot_core32: PE32 executable (GUI) Intel 80386, for MS Windows trickbot_core64: PE32+ executable (GUI) x86-64, for MS Windows A quick check of the 32-bit2 binary in IDA looks great: If you’ve ever reversed TrickBot, you can quickly tell that this, indeed, is TrickBot, because of the CoInitialize* calls. Interestingly, IDA detects wWinMain in the 32-bit version and jumps there as soon as you load the binary, while the 64-bit version sets you back to the real entry point, start, because the actual main (user entry point) function couldn’t be found automatically. That, however, is analysis of the malware itself, and will happen in the next part. To be continued… Be careful: select from the exact start of the imports table, not from 1/2/3 bytes before - else IDA won’t recognize it and won’t help. &#8617; The x64 decompiler produces crappy output for this specific binary, which is why I chose the 32-bit version &#8617;" />
<meta property="og:description" content="In my previous post, I explained how to unpack the TrickBot loader. In this one, I will explain how to dump both versions of the core (x86 and x64). The dumping part in itself is not so interesting as are the ways you can make IDA help you easily understand what’s going on. Starting analysis After dropping the binary in IDA and poking around a bit, you see a bunch of functions and hidden imports, which doesn’t help much: This doesn’t really mean anything at this point, other than a bunch of random symbols. So, let’s get some runtime / dynamic information. If you run the binary, you’ll see something particularly interesting: It is the first called function, and some parameters are passed to it. If you step over it and check the values of those addresses, you’ll quickly see that, in the first parameter, there’s a number that looks like an offset: IDA also marked is as a function pointer, so if you put the cursor over it and press O (to mark as an offset), you get: Effectively, the 0x7XXXXXXX offset and the type information hints from IDA were right: it’s a function pointer, pointing to a Windows API call. This means that the function probably initializes the imports table. However, after initializing the imports, they still look ugly in the decompiler: off_404010(0); Of course, you could go and rename each API call manually, but really, you don’t want to do that. You have the start of the imports table, and if you look at the second parameter of the previously mentioned IAT-loading function, you see: .rdata:00403228 dword_403228 dd 200h ; DATA XREF: start+15↑o Indeed, that’s the size of the imports table, but, news flash: you don’t even need to know it! Prettifying the imports dword_xxxxxxxx(arg) does not help, but IDA already knows about these tricks, and is ready to help. To fix the ugly imports, all you have to do is find the start of the imports table, select it1 and then let IDA know about them. To do this, go to the previously mentioned offset (start of imports table), put the cursor there, and press Alt + L to start a new selection: that is, you’re telling IDA that, no matter if you lose the focus of the window or click somewhere, it should still keep the selection. This is very useful for when you have to select a big chunk of memory, such as an imports table: Then, as shown in the previous GIF, scroll down until you find the end, which you can find intuitively: when you stop seeing 0x7XXXXXXX offsets, then you’ve found the end of the imports table. It’s as easy as it sounds. And if you have multiple import tables (or a single import table is split over multiple regions), you can repeat the process with each chunk. Now that you have the table selected, it’s time to rename these offsets. Luckily, IDA already ships with an IDC script designed exactly for this purpose: ida_root/idc/renimp.idc. To use it, press Alt + F7, then navigate to the script, select it, press Alt + L again (to cancel the selection), and all the imports will be renamed: Now that we have the imports renamed, the binary looks much better: Compare that to the old view: Now that the binary is much easier to understand, we can quickly reverse some functions (without going too deep into it) and get a global overview of what is the binary doing: As mentioned in the title, this is just a loader that moves itself to a temporary directory, checks OS information (32-bit or 64-bit), and loads the appropiate binary. As you can see in the image, I’ve highlighted the variable that is used to decide which resource to load and decode, so in order to dump it, all you have to do is put a breakpoint after DecodeStream and dump len bytes from buf, then run the binary again, invert the if ( os_version ) check, and dump len bytes from buf, again, to have both binaries: ➜ ~ file * trickbot_core32: PE32 executable (GUI) Intel 80386, for MS Windows trickbot_core64: PE32+ executable (GUI) x86-64, for MS Windows A quick check of the 32-bit2 binary in IDA looks great: If you’ve ever reversed TrickBot, you can quickly tell that this, indeed, is TrickBot, because of the CoInitialize* calls. Interestingly, IDA detects wWinMain in the 32-bit version and jumps there as soon as you load the binary, while the 64-bit version sets you back to the real entry point, start, because the actual main (user entry point) function couldn’t be found automatically. That, however, is analysis of the malware itself, and will happen in the next part. To be continued… Be careful: select from the exact start of the imports table, not from 1/2/3 bytes before - else IDA won’t recognize it and won’t help. &#8617; The x64 decompiler produces crappy output for this specific binary, which is why I chose the 32-bit version &#8617;" />
<link rel="canonical" href="https://qmemcpy.io/post/reverse-engineering-malware-trickbot-part-2-loader" />
<meta property="og:url" content="https://qmemcpy.io/post/reverse-engineering-malware-trickbot-part-2-loader" />
<meta property="og:site_name" content="qmemcpy - random bits of reverse engineering" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-10-03T02:00:00+02:00" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:site" content="@qmemcpy" />
<meta name="twitter:creator" content="@qmemcpy" />
<script type="application/ld+json">
{"name":null,"description":"In my previous post, I explained how to unpack the TrickBot loader. In this one, I will explain how to dump both versions of the core (x86 and x64). The dumping part in itself is not so interesting as are the ways you can make IDA help you easily understand what’s going on. Starting analysis After dropping the binary in IDA and poking around a bit, you see a bunch of functions and hidden imports, which doesn’t help much: This doesn’t really mean anything at this point, other than a bunch of random symbols. So, let’s get some runtime / dynamic information. If you run the binary, you’ll see something particularly interesting: It is the first called function, and some parameters are passed to it. If you step over it and check the values of those addresses, you’ll quickly see that, in the first parameter, there’s a number that looks like an offset: IDA also marked is as a function pointer, so if you put the cursor over it and press O (to mark as an offset), you get: Effectively, the 0x7XXXXXXX offset and the type information hints from IDA were right: it’s a function pointer, pointing to a Windows API call. This means that the function probably initializes the imports table. However, after initializing the imports, they still look ugly in the decompiler: off_404010(0); Of course, you could go and rename each API call manually, but really, you don’t want to do that. You have the start of the imports table, and if you look at the second parameter of the previously mentioned IAT-loading function, you see: .rdata:00403228 dword_403228 dd 200h ; DATA XREF: start+15↑o Indeed, that’s the size of the imports table, but, news flash: you don’t even need to know it! Prettifying the imports dword_xxxxxxxx(arg) does not help, but IDA already knows about these tricks, and is ready to help. To fix the ugly imports, all you have to do is find the start of the imports table, select it1 and then let IDA know about them. To do this, go to the previously mentioned offset (start of imports table), put the cursor there, and press Alt + L to start a new selection: that is, you’re telling IDA that, no matter if you lose the focus of the window or click somewhere, it should still keep the selection. This is very useful for when you have to select a big chunk of memory, such as an imports table: Then, as shown in the previous GIF, scroll down until you find the end, which you can find intuitively: when you stop seeing 0x7XXXXXXX offsets, then you’ve found the end of the imports table. It’s as easy as it sounds. And if you have multiple import tables (or a single import table is split over multiple regions), you can repeat the process with each chunk. Now that you have the table selected, it’s time to rename these offsets. Luckily, IDA already ships with an IDC script designed exactly for this purpose: ida_root/idc/renimp.idc. To use it, press Alt + F7, then navigate to the script, select it, press Alt + L again (to cancel the selection), and all the imports will be renamed: Now that we have the imports renamed, the binary looks much better: Compare that to the old view: Now that the binary is much easier to understand, we can quickly reverse some functions (without going too deep into it) and get a global overview of what is the binary doing: As mentioned in the title, this is just a loader that moves itself to a temporary directory, checks OS information (32-bit or 64-bit), and loads the appropiate binary. As you can see in the image, I’ve highlighted the variable that is used to decide which resource to load and decode, so in order to dump it, all you have to do is put a breakpoint after DecodeStream and dump len bytes from buf, then run the binary again, invert the if ( os_version ) check, and dump len bytes from buf, again, to have both binaries: ➜ ~ file * trickbot_core32: PE32 executable (GUI) Intel 80386, for MS Windows trickbot_core64: PE32+ executable (GUI) x86-64, for MS Windows A quick check of the 32-bit2 binary in IDA looks great: If you’ve ever reversed TrickBot, you can quickly tell that this, indeed, is TrickBot, because of the CoInitialize* calls. Interestingly, IDA detects wWinMain in the 32-bit version and jumps there as soon as you load the binary, while the 64-bit version sets you back to the real entry point, start, because the actual main (user entry point) function couldn’t be found automatically. That, however, is analysis of the malware itself, and will happen in the next part. To be continued… Be careful: select from the exact start of the imports table, not from 1/2/3 bytes before - else IDA won’t recognize it and won’t help. &#8617; The x64 decompiler produces crappy output for this specific binary, which is why I chose the 32-bit version &#8617;","url":"https://qmemcpy.io/post/reverse-engineering-malware-trickbot-part-2-loader","headline":"Reverse engineering malware: TrickBot (part 2 - loader)","dateModified":"2017-10-03T02:00:00+02:00","datePublished":"2017-10-03T02:00:00+02:00","sameAs":null,"@type":"BlogPosting","author":{"@type":"Person","name":"qmempcy"},"image":null,"publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"https://qmemcpy.io/assets/command_line.png"},"name":"qmempcy"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://qmemcpy.io/post/reverse-engineering-malware-trickbot-part-2-loader"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->



	</head>

	<body>

		<aside class="logo">

	
	

	<a href="/">
		<img src="/assets/command_line.png" class="gravatar">
	</a>

</aside>


		<main>
			<article>

	<div class="center">
		<h1>Reverse engineering malware: TrickBot (part 2 - loader)</h1>
		<time>October 3, 2017</time>
	</div>

	<div class="divider"></div>

	<p>In my <a href="/post/reverse-engineering-malware-trickbot-part-1-packer">previous post</a>, I explained how to unpack the TrickBot loader.</p>

<p>In this one, I will explain how to dump both versions of the core (x86 and x64). The dumping part in itself is not so interesting as are the
ways you can make IDA help you easily understand what’s going on.</p>

<hr />

<h1 id="starting-analysis">Starting analysis</h1>

<p>After dropping the binary in IDA and poking around a bit, you see a bunch of functions and hidden imports, which doesn’t help much:</p>

<p><img src="https://i.imgur.com/76ksYbQ.png" alt="hidden imports" /></p>

<p>This doesn’t really mean anything at this point, other than a bunch of random symbols. So, let’s get some runtime / dynamic information.</p>

<p>If you run the binary, you’ll see something particularly interesting:</p>

<p><img src="https://i.imgur.com/TdEj6MS.png" alt="something interesting" /></p>

<p>It is the first called function, and some parameters are passed to it. If you step over it and check the values of those
addresses, you’ll quickly see that, in the first parameter, there’s a number that looks like an offset:</p>

<p><img src="https://i.imgur.com/asuxLOo.png" alt="looks like an offset" /></p>

<p>IDA also marked is as a function pointer, so if you put the cursor over it and press <kbd>O</kbd> (to mark as an offset), you get:</p>

<p><img src="https://i.imgur.com/FQoGkzf.png" alt="function pointer" /></p>

<p>Effectively, the <code class="highlighter-rouge">0x7XXXXXXX</code> offset and the type information hints from IDA were right: it’s a function pointer, pointing to a Windows
API call. This means that the function probably initializes the imports table.</p>

<p>However, after initializing the imports, they still look ugly in the decompiler:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  off_404010(0);
</code></pre>
</div>

<p>Of course, you could go and rename each API call manually, but really, you don’t want to do that. You have the start of the imports table,
and if you look at the second parameter of the previously mentioned IAT-loading function, you see:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>.rdata:00403228 dword_403228 dd 200h                    ; DATA XREF: start+15↑o
</code></pre>
</div>

<p>Indeed, that’s the size of the imports table, but, news flash: you don’t even need to know it!</p>

<h1 id="prettifying-the-imports">Prettifying the imports</h1>

<p><code class="highlighter-rouge">dword_xxxxxxxx(arg)</code> does not help, but IDA already knows about these tricks, and is ready to help. To fix the ugly imports, all you have to
do is find the start of the imports table, select it<sup id="fnref:1"><a href="#fn:1" class="footnote">1</a></sup> and then let IDA know about them.</p>

<p>To do this, go to the previously mentioned offset (start of imports table), put the cursor there, and press <kbd>Alt</kbd> + <kbd>L</kbd> to start a new <em>selection</em>:
that is, you’re telling IDA that, no matter if you lose the focus of the window or click somewhere, it should still keep the selection. This is very useful for when you have to select
a big chunk of memory, such as an imports table:</p>

<p><img src="https://i.imgur.com/sA031wQ.gif" alt="big selection" /></p>

<p>Then, as shown in the previous GIF, scroll down until you find the end, which you can find intuitively: when you stop seeing <code class="highlighter-rouge">0x7XXXXXXX</code> offsets, then you’ve found
the end of the imports table. It’s as easy as it sounds. And if you have multiple import tables (or a single import table is split over multiple regions), you can repeat the process
with each chunk.</p>

<p>Now that you have the table selected, it’s time to rename these offsets. Luckily, IDA already ships with an IDC script designed exactly for this purpose: <code class="highlighter-rouge">ida_root/idc/renimp.idc</code>.
To use it, press <kbd>Alt</kbd> + <kbd>F7</kbd>, then navigate to the script, select it, press <kbd>Alt</kbd> + <kbd>L</kbd> again (to cancel the selection), and all the imports
will be renamed:</p>

<p><img src="https://i.imgur.com/QXQUec8.gif" alt="all imports renamed" /></p>

<p>Now that we have the imports renamed, the binary looks much better:</p>

<p><img src="https://i.imgur.com/lGQ8izK.png" alt="much better" /></p>

<p>Compare that to the old view:</p>

<p><img src="https://i.imgur.com/v1u2XlF.png" alt="old view" /></p>

<p>Now that the binary is much easier to understand, we can quickly reverse some functions (without going too deep into it) and get a global overview of what is the binary doing:</p>

<p><img src="https://i.imgur.com/DFAS2CO.png" alt="overview" /></p>

<p>As mentioned in the title, this is just a loader that moves itself to a temporary directory, checks OS information (32-bit or 64-bit), and loads the appropiate binary. As you
can see in the image, I’ve highlighted the variable that is used to decide which resource to load and decode, so in order to dump it, all you have to do is put a breakpoint
after <code class="highlighter-rouge">DecodeStream</code> and dump <code class="highlighter-rouge">len</code> bytes from <code class="highlighter-rouge">buf</code>, then run the binary again, invert the <code class="highlighter-rouge">if ( os_version )</code> check, and dump <code class="highlighter-rouge">len</code> bytes from <code class="highlighter-rouge">buf</code>, again, to have both
binaries:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>➜  ~ file *
trickbot_core32: PE32 executable (GUI) Intel 80386, for MS Windows
trickbot_core64: PE32+ executable (GUI) x86-64, for MS Windows
</code></pre>
</div>

<p>A quick check of the 32-bit<sup id="fnref:2"><a href="#fn:2" class="footnote">2</a></sup> binary in IDA looks great:</p>

<p><img src="https://i.imgur.com/DgF33cO.png" alt="32-bit binary" /></p>

<p>If you’ve ever reversed TrickBot, you can quickly tell that this, indeed, is TrickBot, because of the <code class="highlighter-rouge">CoInitialize*</code> calls. Interestingly, IDA detects <code class="highlighter-rouge">wWinMain</code> in the
32-bit version and jumps there as soon as you load the binary, while the 64-bit version sets you back to the real entry point, <code class="highlighter-rouge">start</code>, because the actual <code class="highlighter-rouge">main</code> (user entry point)
function couldn’t be found automatically. That, however, is analysis of the malware itself, and will happen in the next part.</p>

<p><em>To be continued…</em></p>

<hr />
<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p>Be careful: select from the exact start of the imports table, not from 1/2/3 bytes before - else IDA won’t recognize it and won’t help. <a href="#fnref:1" class="reversefootnote">&#8617;&#xfe0e;</a></p>
    </li>
    <li id="fn:2">
      <p>The x64 decompiler produces crappy output for this specific binary, which is why I chose the 32-bit version <a href="#fnref:2" class="reversefootnote">&#8617;&#xfe0e;</a></p>
    </li>
  </ol>
</div>


</article>

<div class="page-navigation">
	
    <a class="next" href="/post/reverse-engineering-malware-trickbot-part-3-core" title="NEXT: Reverse engineering malware: TrickBot (part 3 - core)">&lt;&lt;</a>
		<span> &middot; </span>
  
		<a class="home" href="/" title="Back to Homepage">Home</a>
  
		<span> &middot; </span>
    <a class="prev" href="/post/reverse-engineering-malware-trickbot-part-1-packer" title="PREV: Reverse engineering malware: TrickBot (part 1 - packer)">&gt;&gt;</a>
  
</div>

		</main>

		<div class="footer">
  <span class="block">Made with &hearts; using <a href="http://jekyllrb.com/">Jekyll</a> &amp; <a href="https://github.com/heiswayi/the-plain" title="The Plain theme by Heiswayi Nrird">The Plain</a></span>
  <span class="block"><a href="https://github.com/qmemcpy" title="Hosted on GitHub" target="_blank">GitHub</a> &middot; <a href="https://twitter.com/qmemcpy" target="_blank">twitter</a> &middot; <a href="/about">about</a></span>
  <span>
  	feeds: <a href="/feed.xml" target="_blank">rss</a> &middot; <a href="/atom.xml" target="_blank">atom</a> &middot; <a href="/sitemap.xml" target="_blank">sitemap</a>
  </span>
  <span class="block">&copy; 2017 qmemcpy</span>
</div>

		<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-99919043-1', 'auto');
  ga('send', 'pageview');

</script>


	</body>

</html>
